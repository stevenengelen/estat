# Head First HTML and CSS

## getting to know HTML - The Language of the Web

HTML is served by a web server to a web browser and tells the browser how to display a page. Comments are put in using `<!-- Comment -->`. 

HTML tells the browser about the *structure* of a page. It's a markup language.

    <html>              <!--tells the browser this is a html file-->
        <head>          <!--the head section contains information about the page-->
            <title> ..... </title>      <!--appears at the top of the browser-->
            <style type="text/css">     <!--the style element adds style to your page-->
                                        <!--the type tells the browser what style you 
                                            are using. This is obsolete, as for now CSS is
                                            the only style available.-->
                                        <!--the style element needs always to be in the
                                            <head> element.-->
                body {                  <!--the body means that all css between the { and }
                                            will be applied to the content in the <body>
                                            element-->
                     ...
                    }
            </style>
        </head>

        <body>          <!--the body contains the content of the web page, what you see in
                            the browser-->
            .....
        </body>
    </html>

An **Element = Opening tag + Content + Closing Tag** .

An element can have attributes. They give extra info about the element. *type* in the `<style>` element in the above example is an attribute.

HTML gives you a way to describe the structure of the content in your file. HTML does not describe how things should be displayed, it just provides structure to the things to be displayed. The browser uses it's build in style to present how this structure will be displayed.  
If you want another style, you can use CSS. CSS gives a way to describe *how* your content should be presented.  
CSS means **C**ascading **S**tyle **S**heets.
It is used to control the presentation of the HTML.

## Meeting the HT in HTML

    <a href = "file.html">text_to_link</a>  <!--href attribute specifies the destination-->

When the user clicks the link, the browser gets the value of the href attribute, and loads the file it finds therein.  
href means "hypertext reference". It can reference other html files, pdf files, etc. . Instead of text, we can also put an `<img>`, etc. as content of the `<a>` element, so you can go to the link by clicking an image.  
Attributes always are placed in the opening tag, attribute name first (like href), followed by = and the value between quotes.  
Only in HTML 5 you can make your own attributes. Lower versions of html only support a predefined set of attributes (the supported attributes).  

## Web Page Construction

When constructing a page:

1. create a rough sketch, sketch the page with large structural elements, naming titles (already using the text that will be displayed), etc. .
2. translate that sketch into an outline by putting basic HTML building blocks (like `<h1>`, `<p>`) on the large structural elements (define the block elements, see below).
3. translate the outline into real HTML
4. add enhancements

`<q>` quotes a text (and most browsers add the \"...\" double quotes for you).

`<blockquote>` is used for longer quotes that needs to be displayed on their own, they break out on their own in the webpage, unlike the `<q>` for short quotes, which are kept part of the `<p>` when used within.

        <p>
        I saw some Burma Shave style signs on the side of the road today: 
        </p>
        <blockquote>
            Passing cars, 
            When you can't see, 
            May get you, A glimpse, 
            Of eternity.
        </blockquote>
        <p>
            I definitely won't be passing any cars.
        </p>

If needed, we can use `<p>` etc. inside the `<blockquote>`.  
`<blockquote>` is a *block element*. A block element is a thing that has returns around it, like a paragraph, a heading, etc. . The browser will add returns with block elements when displaying content.  
`<q>` is an inlne element, it just goes with the flow it is in, without interrupting that flow (with a return). The browser does not add returns.

Block elements stand on their own, inline elements go with the flow.

`<br>` explicitly tells the browser to add a line break.  
`<br>` is an element without content, thus a `</br>` is not needed. `<br>` is a void element (there are more than `<br>` alone, `<img>` is also one). A void element has no closing tag. Non-void elements (like `<p>`) are called normal elements. An empty element is an element with an opening and closing tag, but with no content.  

`<ol>` is used for ordered lists, `<ul>` is used for unordered lists. In the list element you put `<li>` elements, to mark the list items.  

`<dl>` is a definition list. It has `<dt>` defintion term and `<dd>` definition description pairs.

        <dl>
            <dt>Burma Shave Signs</dt>
            <dd>Road signs common in the U.S. in the 1920s and 1930s advertising shaving products.</dd>
            <dt>Route 66</dt>
            <dd>Most famous road in the U.S. highway system.</dd>
        </dl>

A character entity is used to put HTML specific characters in your content, e.g `&lt;` is the < sign. Even untypeable characters like copyright have a character entity.

    The &lt;html&gt; element rocks <!--The <html> element rocks-->

Also try `&amp;`, `&copy;` . You can also use the numerical version, like `&#100;`.

`<strong>`, `<time>`, `<pre>` and `<code>` are other html elements.

## A Trip to Webville

http://www.mydomain.com/index.html

URL is the **U**niversal **R**esource **L**ocator. It specifies where something can be found on the web, and also names the **protocol** you can use to retrieve the resource.  
So, the first part of a URL is the protocol, it is used by the browser and the server to know how to get the resource asked for in the URL.  
The www.mydomain.org part is called the website part of the URL.  
The part after the website part is the absolute path to the resource requested.

HTTP error #404 means the server can't find the requested file.

URL uses an absolute path, from the root folder of your website (that's why we have a '/', meaning root, after the website part of the URL).

When clicking on a link with a relative path (a `<href>` with a relative path), the browser transforms this relative path to an absolute path behind the scenes before sending the request to the server.  

When requesting for a directory, the webserver tries to respond with a default file in that directory (in URL we speak of directries, not folders). *index.html* and *default.htm* are default files.

When the server gets a request for e.g. http://www.strabuzcoffee.com, and there is a directory with that name, the server adds the / implicitely. In that case www.starbuzz.com is equal to www.starbuzz.com/ and is possibly equal to www.starbuzz.com/index.html .

Best use realtive links to your own pages, and URL links to offsite pages.

`<a>` has an attribute called title. It is a textual description of the page you are linking to. On some browsers this title value is displayed in a tooltip, used for the visually impaired, ..... .  
The `<title>` attribute can be used on every element, so e.g. a tooltip on a heading is possible.

            Read the <a href = "http://wickedlysmart.com/buzz"
                title = "Read all about caffeine on the Buzz">Caffeine Buzz</a>

id is an attibute for any element to identify it. The id can be used in e.g. a `<a>` tag.

        <h2 id = "chai">Chai Tea, $1.85</h2> <!--first id the element-->
        <a href = "index.html#chai">See Chai</a>  <!--then reference it adding #id at the end of the href-->

The target attribute to a `<a>` element tells to browser where to open the link. If no target is given, it is by default the same window. If the value "\_blank" is given, it is *always* a new window. If you want to use another window but keep opening pages in that window instead of always generating new windows (as "\_blank" does), just give that window a name (e.g. target = "coffee") and reuse that name in other references to open those references in that single new window.

            Read the <a href = "http://wickedlysmart.com/buzz/index.html#Coffee"
                title = "Read all about caffeine on the Buzz"
                target = "_blank">Caffeine Buzz</a>

## Meeting the Media

Images are requested at the server after the requested page containing the images has arrived at the browser, and during processing of the requested page by the browser.  

Use JPEG for photos and complex graphics.  
Use PNG or GIF for images with solid colors, logos, and geometric shapes.  
PNG can support both logos and pictures, and is the latest newcomer. It also offers multiple transparancy.  
GIF is the only one that supports animation.  
GIF and PNG are lossless, JPEG is lossy.

    <img src = "some_absolute_or_relative_path_to_an_image">

There is no "default" image when only a path to a directory is given (like index.jpeg or so).  
`<img>` is an inline void element.

The alt attribute gives an alternative in case the image is not found.

        <p><img src = "http://wickedlysmart.com/hfhtmlcss/trivia/broken.png"
                alt = "The typical new pencil can draw a line 35 miles long."></p> 

width and height attributes are best used to give the width and height of the image in pixels. It is best to give the exact values, so the browser can predtermine the layout when loading the HTML before loading the pictures. It is not really advisable, but you can use height and width attributes for resizing too. Moreover, before resizing, the browser gets the full image, so you won't win on bandwidth by downsizing.  

Web pages and images are best not over 800 pixels wide.

We use 96 ppi (pixels per inch) when calculation the size of a picture. So a picture of 1 by 1 inch, is 96 pixels by 96 pixels. 

Anti-aliasing is blending the edges of text, transparant images, images, etc. in with the background color. It is pleasant and soft for the eyes.

## Getting Serious with HTML

Tell your browser which markup language in which version you are using.

    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

`<!DOCTYPE>` is not an HTML element, since it starts with a !. The above tells us that the document's root starts with html, it uses a PUBLICaly available standard, HTML 4.01, markup is written in ENglish, and a pointer to a file that identifies this particular standard.  
These doctype definitions belong at the top of the HTML file.

    <!doctype html>

This simple doctype definition tells that we are using HTML5 in our HTML file. HTML5 is a living (rolling release) standard, so, here we tell the browser we are using HTML. And that is enough information. The version numbers stop here.  
The latest version of HTML is always backwards compatible. So if you write standard HTML today, it will be standard HTML tomorrow, and forever on.

Learning HTML5 is learning HTML. HTML5 is the last version, and is backwards compatible. Actually, HTML5 is HTML. HTML5 is a living standard for HTML, not HTML5.

The W3C has a free validator to validate a HTML page (like a spell checker). 

    <meta charset = "utf-8">

This tells the browser to use Unicode character encoding. meta tells the browser something **about** the page, utf8 is an encoding in the Unicode family. The `<meta>` tag belongs in the `<head>` element, as the first line. The `<head>` contains information **about** the page.

Following the standard, your pages will display more quickly and with fewer differenes between browsers, and the CSS will work better.

## Adding a Little Style

    p { background-color : red; }

The thing is called a rule. It's basic form is *html-element { property : value }*. The thing before the brackets (the p) is called a selector. Between the brackets, we have one or more properties and values. They make up a property declaration.  
You add rules to a HTML file by enclosing them with the `<style>` tag in the `<head>` section.

    <style>
        p { color : maroon; }
    </style>

The p selector selects all the paragraphs in the HTML.  

        h1, h2 {
            font-family : sans-serif;
            color : gray;
        } /*we want this for both types of headings*/
        h1 {
            border-bottom : 1px solid black;
        } /*but this only for a h1 type of heading*/ 

Selectors can be made up of multiple HTML elements, combined using a comma separator.  
Rules are evaluated top to bottom.  
  
    <link type = "text/css" rel = "stylesheet" href = "lounge.css">

The link element links external information. In this case we link to a stylesheet, so this is placed in the `<head>` section. The rel attribute specifies the relationship between the HTML file and the thing we are linking to. `<link>` is a void element.  

Fonts with serifs are more difficult to read on a computer screen. That's why sans-serif font are so beautiful on a computer screen.

Some of the style is inherited by elements below the elements on which the style is defined on (e.g. when style selector font is to a `<p>` element, all the elements in the `<p>` will inherit the same fonts). Inheritance can be overriden.  

    <p class = "classname"> ..... </p>

The class *attribute* makes an element part of a class.

    p.classname { color : green; }

This a class selector. It is made of up *element.class { ..... }*.  
The selector p.classname selects all the p elements in the class *classname*.

    .classname { color : green; }

If you leave out all the element names, then the rule will apply to all members of the class.  

    <p class = "greentea raspberry blueberry">

This adds the p element to several classes.

But what if all three classes in the CSS define e.g. a different color. Which will be displayed? The most specific rule will win (see later). If they are equal specific (like in the example above), the one that is last in the CSS file will be chosen (blueberry, if the blueberry rule is last in the CSS file).  

Just like the HTML validator, there also is a free available CSS validator by the W3C.  

## Expanding Your Vocabulary

There are 5 fonts families:

* sans-serif
* serif
* monospace
* cursive
* fantasy

    body {
        font-family : Verdana, Geneva, Arial, sans-serif;
    }

If the browser can find the Verdana font, use that. If not, use the next in line and so on. The last font is a non specific font, that sums up the family of the previous ones. It tells the browser to use whatever sans-serif font is set as default (put the least speific fonts at the end, they are a good fallback). All the font in one font-family rule must be of the same family, the family being the last thing on the line in case a fallback is needed.  
"Courier New" is enclosed in quotes, because the font name is two words.

.woff means **w**eb **o**pen **f**ont **f**ormat. Other formats are TrueType (.ttf) fonts, OpenType fonts (.otf), Embedded OpenType fonts (.eot) and SVG fonts (.svg).  

    @font-face {
        font-family : "Emblema One";
        src : url("http://wickedlysmart.com/hfhtmlcss/chapter8/jurnal/EmblemaOne-Regular.woff"),
            url("http://wickedlysmart.com/hfhtmlcss/chapter8/jurnal/EmblemaOne-Regular.ttf");
    }

This uses a font file from a site. This kind of construction, placed at the top of the CSS file, will load the font file in the users their browsers.  
www.google.com/webfonts is a nice place.  

    body {
        font-size : 14px;
    }

Sets the font size to 14 pixels.

    body {
        font-size : 14px;
    }
    h1 {
        font-size : 150%;
    }

h1 font size is set at 150% of 14px, since h1 has body as a parent.

    body {
        font-size : 14px;
    }
    h1 {
        font-size : 150%;
    }
    h2 {
        font-size : 1.2em;
    }

h2 font size will be 1.2 times the body font size.  

    body {
        font-size : small;
    }

The small *keyword* sets the font size to about 12px, which is most browsers definition of small. Other values are xx-small, x-smal, medium, large, x-large and xx-large, with a step of 20% between each. Mind you, each browser has its own meaning of small, ..... .

The best way to define font size is to use a keyword (like small) in your body rule, and use a relative or em value for all its children.  

    font-weight : bold;

sets the font weight to bold.

    font-style : italic;
    font-style : oblique;

makes the font slanted. The difference between italic and oblique is that italic might add serif, and oblique uses the base font (and doesn't add serifs). In any case, behaviour is undetermined between different browsers, so we can't exactly tell what will happen. There are browsers that implicitly use oblique, even when italic is defined in the CSS file.  

The percentage in a color definition is the amount of light of you computer screen you sent throught the color (being red or blue or green).  
So a color is specified by the amount of red, blue and green that goes into the color.  

You can specify a color by

* name: background-color : silver;
* red, green and blue values: background-color : rgb(80%, 40%, 0%); or background-color : rgb(204, 102, 0); (the latter on a scale of 0 to 255, so 1 byte)
* hex codes: background-color : #cc6600 (cc being the red value, 66 the green, .....)

Next to that, CSS has 16 basic colors, including black, white, red, blue, and green and 150 extended colors.  

    em { text-decoration : line-through; }

add decorative effects to the text (like underline, overline, line-through and none).  
You can use more than one effect at the same time, seprate the effects with a comma.  

## Getting Intimate with Elements

    line-height : 1.6em;

changes the space between the lines to 1.6 time the font height. Pixels or percentages are good as well.  

All elements are treated like boxes by CSS. Paragraphes, heading, blockquotes, they are all boxes. What is a box made up of?

A box has a

* content area (text, images, .....), it's just big enough to hold the content
* padding, a box can have a layer of padding around the content area, to create whitespace between the content and the border of the box.
* border, the border surrounds the optional padding, it's a line around the content
* margin, surrounds the border, and is optional. It adds space between your element and other elements. If 2 boxes are next to each other, the margin defines the space between the boxes

So, we can have a content area, surrounded by optional padding, surrounded by an optional border, surrounded by an optional margin. The parts of a box are transparant. You can only style their size, and appearance in the case of borders.  

That's the box model CSS is using!

    background-image :      url(images/background.gif);
    
adds an background image to our page using CSS. It is no substitute for the `<img>` element, since that adds an image element. The CSS version background-image doesn't add an image element, it just sets the background image of an element.  
Notice that the URL doesn't require quotes.

    background-repeat :     no-repeat;
    background-position :   top left;

switches off repeat and positions the background image. Other values are no-repeat, repeat-x (only repeat on the x-axis), repeat-y and inherit (whatever the parent has) AND top, left, right, bottom, center as keywords or pixel or percentages for the position.  

    padding-left :          80px;

adds padding to the left of the content.

    margin-right :          250px;

likewise for margin.

    border-style : groove;

sets the border style. Other styles are solid, double, groove, outset, dotted, dashed, inset and ridges.  

    border-width :  thin;

sets the border width. You can use keywords like thin, medium and thick, or define thickness using pixels.

    border-color:   red;

sets the border color. Define colors like above.

    border-top-color: black;
    border-top-style: dashed;
    border-top-width : thick;

sets properties of one side of the border.

    border-radius :     15px;

rounds all 4 corners.

    border-top-left-radius: 3em;

rounds only 1. em is relative to the font size.

    <p id = "footer">.....</p>

give an id to this paragraph, There is a one-to-one relationship between id's and elements.  
This is unlike a class attribute, where there is a many-to-many relationship with elements.  

    #footer {
        color : red;
    }

selects the element with the footer id in CSS.

    p#footer {
        color : red;
    }

selects the p element in the element with the id footer in CSS (if HTML is e.g. `<body id = "footer"><p>.....</p></body>` .

You can mix stylesheets. Start with a general one, and use some specific on top of that.  
You can do this by loading all the stylesheets in the html file. Order matters, a style sheet can override the styles in the stylesheet linked aboved it.  

You can add queries to links in the HTML to decide if the stylesheet is going to be loaded. You can for instance, load different style sheets for PC with full screen, smartphone, print version, etc. .

    <link href = "lounge-mobile.css" rel = "stylesheet" media = "screen and (max-device-width : 480px) and (orientation : portrait)">

Or, you can use @media queries in the CSS in front of the rules as well, to decide for which devices the rule apply.

    @media screen and(min-device-width : 481px) {
        #guarantee {
            margin-right : 250px;
        }
    }

Link elements have the advantage that you can separate the style of different devices in different CSS files. But, if you specific style is not so big, you can put it in the CSS file using a @media query.

    <link type="text/css" media = "screen and (min-width : 481px)" rel="stylesheet" href="lounge.css">
    <link type="text/css" media = "print" rel="stylesheet" href="lounge-print.css">
    <link type="text/css" media = "screen and (max-width : 480px)" rel="stylesheet" href="lounge-mobile.css">

This opens the door to mobile first development!

## Advanced Web Construction

`<div>` logically groups together *block* elements that logically belong together. It gets an *id* attribute, which can be used in a CSS file.  
`<div>` is actually a container to hold a bunch of stuff together.  
`<div>` means *divide*.

    width : 200px;

sets the width of the content of an element. Even when resizing the browser window width, the size will not adjust. It will always be 200 pixels wide, constantly.  
Once you have set the width of an element, it will no longer autosize when you change the browser window width.

A width of "auto" means the content will expand to fill whatever space is available.  
Width can be expressed in pixels and percentage of the width of the container the element is in.  

It is very rare that you need to set a height.

    text-align : center;

aligns the text to center.

The alignment is only for inline elements. But block elements in a `<div>` inherit the alignment in the `<div>` and align their own content to e.g. center. So `<div>` itself does not align the text in the block elements, but since the block elements inherit from `<div>`, they will apply what they inherited to their content.  
Keep in mind that not all properties are inherited.  

    div h2 { color : black; }

is called a descendant in a selector. This means that all `<div>` elements their `<h2>` will be black.  

    #elixirs h2 { color : black; }

is also a descendant in a selector, but here the color property only applies to the element with the id elixirs.

    #elixirs > h2 { color : black; }

This means that only the direct child of the element with id elixirs gets the color black, not all childs (like grand children and great grand children). In other words, the color property is applied only one level deep.

    #elixirs blockquote h2 { color : blue; }

is also possible. This means the property will start from the h2 element, inside the blockquote element inside the element with the id elixirs.

    line-height = 1;

You can use just a number as line height. You're telling each element in the element that is selected to have a line height of 1 times its own size. So one time the own height of a h2, p, etc. , which will off course be different (for a h2, line height  = 1 means 120% of small, for a p it means 100% of small, .....).

    padding : 0px 20px 30px 10px;

is shortcut writing for padding top, right, bottom and left.

    padding : 20px;

is even shorter. It's 20px for top, right, bottom and left.  
You can do the same thing for margin.

    margin : 0px 20px;

this is short for top and bottom, and right and left.

How about this one:

    border : thin solid #007e7e;

In any order, here width, style and color.  
You can use this too for background property.  

Fonts attributes do require an order:

    font : font-style font-variant font-weight font-size/line-height font-family

font-style, font-variant and font-weight are optional. font-size is mandatory. line height is optional. It is highly recommended to give more than 1 font-family, use commas between them.

`<span>` logically groups together *inline* content.  

So `<span>` and `<div>` actually logically group content for the first and elements for the latter together, so they can be treated like "one new" element. In the case of `<span>`, it will be a "new" inline element, in the case of `<div>`, it will be a new block element.

    a:link {
        color : green;
    }

    a:visited {
        color : red;
    }

    a:hover {
        color : yellow;
    }

styles your links. It's like implicit classes, we call them pseudo classes. The order of the rules is important (e.g. which color will be displayed when hovering over a visited link? Order of rules determines this). The pseudo classes in the example above attach to the different states an element can have (clicked, .....).

Pseudo classes are in your HTML file without typing them in the file. The browser adds them for you.  
There are other then `<a>` pseudo classes too.

CSS is called Cascade Style Sheets, because it of the cascade. The cascade is the way the browser decides, given a bunch of styles in a bunch of stylesheets, which style is going to be used. The various stylesheets are cascaded together.

So, suppose that we want to know the font-size of a h1.
To do this, the browser needs to:

1. Gather all the stylesheets together (stylesheets from the author, the reader and the browser)
2. Find all the declarations that match (here, look at the font-size properties that select a h1)
3. Take all the matches and sort them in the order of author, reader, browser. Author has power of reader, who has power of browser.
4. Within this sort, sort all the declarations by how specific they are (so refine the sort)
5. Finally, sort any conflicting rules in the order they appear in their individual stylesheets

See page 460 to define the specificity. Do the style have id's, classes, elements - 111.

## Arranging Elements

The flow is read from top to bottom, and is what the browser uses to lay out the elements on the page. The HTML is read from top to bottom, each block element separated by a linebreak. By default, each block element takes up the entire width of the browser window.  
So block elements flow from top to bottom, with a newline in between. Inline flow horizontally, from top left to bottom right, next to each other, and inside a block element.  
Note that the margins of 2 block elements placed on top of each other are collapsed into a margin the size of the greatest of the two. So One element with 20px bottom margin placed on top of one with 10px top margin, will have a collapsed margin between them of 20px. This even goes for an element nested in one of the elements touching. Unless you put a border around the outer element, then the margins are not touching.  

    #sidebar {
        padding : 15px;
        margin : 0px 10px 10px 10px;
        width : 280px;
        float : right;
    }

A floating element must have a width other than auto. A floating elements floats as far as possible to the side you define, and the HTML coming after the float is then flowed as usual. The block elements are flowed like if the float element isn't there, but the inline elements in the block elements flow around the float borders. So a float element gets removed from the flow.  
The float element does no longer makes part of the flow, since it is "floating" somewhere. Luckely, the inlines repsect the border of the float.
The float property can be set either left or right.  

    #footer {
        clear : right;
    }

means that no floating content is allowed on the right of the footer. If there is floating content to the right, the browser will move the footer down until there no longer is.

So when you make an element float, you need to:

1. Give the element an identity
2. Give the element a width
3. Float the element

Floating elements do not collapse margins.  
Inline elements can be floated as well, the most common used is an image.  
You can consider block elements ignoring floating elements, while inline elements know they are there. Block elements will flow, without looking at floating elements. Inline elements will nicely go around floating elements. They only time a block element knows about a float, is when we use the clear property as above.  

Liquid layouts expand to whatever width we resize the browser to.  
Frozen layouts lock the elements down. They can't move at all. The width of the content is fixed, and it doesn't expand or shrink when resizing the browser window.  

    #allcontent {
        width :             800px;
        padding-top :       5px;
        padding-bottom :    5px;
        background-color :  #675c47;
    }

The `<div>` with the allcontent id will have a fixed width of 800px. So no matter how we resize the browser, the `<div>` element will alway be 800px wide.  

Jello layouts lock down the width of the content area in the page, but center it in the browser and allows the margins to expand or shrink when resizing the browser window.

    #allcontent {
        width :             800px;
        padding-top :       5px;
        padding-bottom :    5px;
        background-color :  #675c47;
        margin-left :       auto;
        margin-right :      auto;
    }

like this.

    #sidebar {
        position : absolute;
        top : 128px;
        right : 0px;
        width : 280px;
    }

When an element is absolute positioned, the first thing the browser does is remove it from the flow. It then places the element in the indicated position. The other elements ignore completely the absolute positioned element. The inline content of the other elements doesn't even flow around it.  
You can layer multiple absolute positioned elements. The *z-index* determines who is on top of who.  

You can create tables in CSS. Each cell in a table contains a block element.  
So, we need a block element for the table, inside it a block element for each row and inside a block element for each column element in that row.

    #tableContainer {
        display : table;
        border-spacing : 10px;
    }

    div#tableRow {
        display :       table-row;
    }

    #main {
        display :         table-cell;
        background:       #efe5d0 url(images/background.gif) top left;
        font-size:        105%;
        padding:          15px;
        vertical-align :  top;
    }

    #sidebar {
        display :         table-cell;
        background:       #efe5d0 url(images/background.gif) bottom right;
        font-size:        105%;
        padding:          15px;
        vertical-align :  top;
    }

is the way you do this in CSS.  
border-spacing adds border spacing to the cells in the table. This makes margins obsolete. Mind that border-spacing and regular margins do not collapse (see above).  
vertical-align is top, as opposed to middle or bottom.  
Tables are a good layout strategy for multicolumn layouts with even columns of content.

Following layouts are possible in CSS:

* The floating layout: great for elements like images in text, also called the frozen layout.
* The jello layout: from frozen (with a fixed width) we make a jello by allowing margins to expand with the auto property, used e.g. for blogs.
* The absolute layout: a liquid layout with specific width and positioning (used when you want one part of the page to be fixed, and the other part to expand or contract).
* The table display layout: columns that expand and contract.



    `#coupon {
        position : fixed;
        top : 300px;
        left : -90px;
    }`


This is fixed positioning. The difference with absolute positioning is that fixed positioning is an offset to the edge of the browser window, not an offset to the page itself. So, when we move the page by scrolling, the fixed element stays in place, because it is offset to the browser window.  
The browser window is also called the viewport.  
A left position of -90px to the viewport means that the left of the image will be offset -90 to the left of the viewport border, so the browser will start showing the coupon picture at -90px.

        -------------
        | viewport  |
    ---------       |
    |image  |       |
    ---------       |
    -90 px          |
        |           |
        -------------

The four values of the position property are:

* static: you don't specify any positioning, the element is in the normal flow
* absolute: takes an element completely out of the flow and places it relative to the sides of the page or the containing element (absolute element inside another element). They can be layered (according to z-index, see above).
* fixed: relative to the viewport
* relative: relative to its containing element by leaving it in the normal flow and shifting it over by a specified amount. They are first placed by the normal flow, and then shifted , leaving a empty space on where they were before the shift (in the normal flow). Their top, right, left and bottom properties are offset from the element's position in the normal flow.

The properties top, right, bottom and left are used to position absolute, fixed and relative positioned elements.

CSS3 introduces basic animation of elements (out of scope of the book).  
If you want more, use JavaScript.  

## Modern HTML

There are a lot of `<div>`, like `<div id = "footer">` that means nothing to the browser (or search engine or reader), but that occur a lot. In HTML 5 these `<div>` are replaced by actual elements, giving more meaning to the content.

Some HTML 5 elements are:

* `<article>`: a self contained composition in a page
* `<nav>`: for grouping navigation links in a page
* `<header>`: content that goes at the top of the page or top of the section
* `<footer>`: content that goes on the bottom of the page or bottom of the section
* `<time>`: date and time or both
* `<aside>`: content that is supplemental to a page, like a callout or a sidebar
* `<section>`: a thematic grouping of related content, typically with header and footer
* `<video>`: video media

Use

* `<div>` to style the page or create structure for content that doesn't fit in the new HTML5 elements
* `<section>` to define a section of related content
* `<article>` to define content that can be reused or distributed independently from the rest of the content of the page

Here is how we create a `<nav>`:

    <nav>
        <ul>
                <li><a href = "index.html">HOME</a></li>
                <li class = "selected"><a href = "blog.html">BLOG</a></li>
                <li><a href = "">INVENTIONS</a></li>
                <li><a href = "">RECIPES</a></li>
                <li><a href = "">LOCATIONS</a></li>
        </ul>
    </nav>

Note the class called "selected".


    nav ul {
        margin : 0px;                   /*we remove the default margin of ul elements*/
        list-style-type : none;         /*we remove the bullets from the list item*/
        padding : 5px 0px 5px 0px;
    }

    nav ul li {
        display : inline;               /*we make the list items inline, so there will be no CR between them*/
        padding : 5px 10px 5px 10px;
    }

    nav ul li a:link, nav ul li a:visited {
        color : #954b4b;
        border-bottom : none;
        font-weight : bold;
    }

    nav ul li.selected {
        background-color : #c8b99c;
    }

Notice that we add *nav* to every element of the navigation bar, so that when `<ul>` is used somewhere outside a navigation bar, it won't get styled the way it does in the navigation bar (and it will be styled like normal `<ul>`).  
In general **add the most specific rule you can to style your elements**.

Video is done by:
    
    <video controls autoplay width = "512" height = "228" src = "video/tweetsip.mp4">
    </video>

*controls* tells the browser we want to see the controls (like the start - pauze button, .....). *autoplay* starts the video upon loading the page.  

Autoplay is a boolean attribute, it doesn't have a specified value (just putting it there sets the value to true, not putting it to false).  

There also is the possibility to show an image when the video is not playing using the *poster* attribute:

    poster = "images/poster.png"

Don't over use autoplay! Most of the time, users want to decide themselfs if a video is played or not.

    preload = "none" | "metadata" | "auto"

doesn't apply preload (and starts downloading the video when the user clicks play), or only preloads the metadata, or uses the default (auto) applied by the browser.

    loop

autoloops the video

It's best to use the native width and height, so the browser doesn't need to scale the video in real time. Either way, the viewport defined by width and height will be filled to the maximum, but with respect to the aspect ratio (e.g. 4:3 or 16:9).

Always check if the browser supports the format of the video you want to play. The HTML5 specification allows for any video format. It is the browser implementation that determines what formats are actually supported.  
A video consists of an encoded video part and an encoded audio part. The most video common encodings are H.264, VP8 and Theora. The most common audio encodings are AAC and Vorbis.  
Both parts and the meta data are put in a container. The most common containers are WebM, MP4, Ogg and Flash Video.  

To solve the problem that not all browsers support all formats, we can do this:

    <video controls autoplay width = "512" height = "228">
        <source src = "video/tweetsip.mp4">
        <source src = "video/tweetsip.webm">
        <source src = "video/tweetsip.ogv">
        <p>Sorry, your brower doesn't support the video element</p>
    </video>

Note that the *src* attribute is gone, and replaced by `<source>` elements. The browser will read the list and use the first format it supports (or display the paragraph if none).

To decide if the browser can play the format, the browser reads the meta data of the container. This can be time consuming. We can help the browser by giving it the information it needs like this:

    <video controls autoplay width = "512" height = "228">
        <source src = "video/tweetsip.mp4" type = 'video/mp4; codecs = "avc1.42E01E, mp4a.40.2">`
        <source src = "video/tweetsip.webm" type = 'video/webm; codecs = "vp8, vorbis">`
        <source src = "video/tweetsip.ogv" type = 'video/ogg; codecs = "theora, vorbis">`>
        <p>Sorry, your brower doesn't support the video element</p>
    </video>

Type is the MIME type, notice the single and double quotes, because we can't have double quotes in double quotes, single quotes are used in the outer part of the type attribute value.  

If you want to include a non HTML5 video standard like flash, you can do that. Instead of using `<source>`, use `<object>`
    
    <object>.....</object> <!--replace the ..... with the path to your flash video-->

Other HTML5 elements are:

* `<progress>`: to show progress on a task
* `<mark>`: for highlighting bits of text
* `<meter>`: to display measurement in a range
* `<audio>`: to include sound content in the page
* `<figurea>`: for self contained content like a photo, diagram or even code listing
* `<canvas>`: to display graphics and animations drawn with JavaScript

## Getting Tabular

A table consistes of

* `<table>`: start of the table
* `<caption>`: table caption (title)
* `<tr>`: table row
* `<th>`: table header
* `<td>`: table data

We can style the table like this

    table {
        margin-left : 20px;
        margin-right : 20px;
        border : thin solid black;
        caption-side : bottom;
    }

    td, th {
        border : thin dotted gray;
        padding : 5px;
    }

    caption {
        font-style : italic;
        padding-top : 8px;
    }

Table cells are like box model, only the margin is a bit different. Table cells have  border spacing instead of margins. Border spacing is applied to all cells, so you can't have a different border spacing for one particular cell.  

    border-spacing : 10px 30px;

sets the horizontal border space to 10px and the vertical to 30px.

    border-collapse : collapse;

collapses the borders of the cells into one. Any value set by border-space will be ignored.

    tr:nth-child(odd) {
         background-color: #fcba7a;
    }

nth-child is a pseudo class (see above). The state is the numerical order of an element in relation to its sibling elements. So in the above example, if the numerical order is even, the rule gets applied.  
How to determine the numerical order?

Consider:
    
    <section>
        <p>     <!--this is the first child, numerical order 1>
        <p>     <!--this is the second child, numerical order 2>
        <p>     <!--this is the third child, numerical order 3>
    </section>

    <td rowspan = "2" class = "right">4,242 ft</td>

The attribute rowspan tell how many rows this table data will span.  
The row below should take into consideration that the row above spans certain elements, and thus the row below will have fewer elements (and exactly fewer `<td>`s than there are spans).  
Columns can be spanned to, using the attribute *colspan*.  

    <td class = "center">
        <table>
            <tr>
                <th>Tess</th><td>5/5</td>
            </tr>
            <tr>
                <th>Tony</th><td>4/5</td>
            </tr>
        </table>

A table inside a table is also possible.  

    table table th {
        background-color : white;
    }

This is a descendant selector. It selects the th of a table inside a table.  

There are list styles for the markers (the bullets, .....):

    li | ul {
        list-style-type : disc | circle | square | none;
    }

or use a custom image as list marker:

    li {
        list-style-image : url(images/backpack.gif);
        padding-top : 5px;
        margin-left : 20px;
    }

You can style `<ol>` too.  
If text in a list item wraps underneath the marker or just underneath the text is determined by the *list-style-poition* CSS attribute. It can have a value of "inside"  or "outside".

## Getting Interactive

So far, we've only send information from the server to the client browser. But what if the browser wants to send information to the server? For this we can use forms.  

1. A filled out form in a browser is packaged and send to the server. 
2. The server passes the form data to a script. 
3. The script processes the data, and creates a new HTML page that is send back to the browser.


1. The browser loads the HTML containing the form. When it encounters form elements, it generates *controls*. Controls is something that allows you to input data.  
2. The user enters data using the controls.
3. The user submits the form, the browser gets to work and packages the data and send it over to the server.
4. The server responds with a HTML page, which is displayed by the browser.
 

    `<!--<form action="http://wickedlysmart.com/hfhtmlcss/contest.php" method="POST">-->`
    `<form action="contest.php" method="POST">`
      <p>Just type in your name (and click Submit) to enter the contest:<br>

        First name: <input type="text" name="firstname" value=""><br>
        Last name:  <input type="text" name="lastname" value=""><br>
        <input type="submit">
      </p>
    </form>`


The `<form>` element has an attribute called action. It tells where the form data should be send to, and which script on the server it should be send to (contest.php). It also tells that the POST method will be used to send data. Other methods are possible (see later).  

In the `<form>` element you can put about any HTML element.  
Off course you can put the elements that create controls in it as well.  
The most important ones are:

* The `<input>` element, the type of input is deciced by the *type* attribute


    `<input type = "text" name = "fullname"> <!--for entering one line of text, this is a void element (see above)-->
    <input type = "submit"> <!--creates a button to submit the form-->

    <input type = "radio" name = "hotornot" value = "hot"> <!--radio buttons-->
    <input type = "radio" name = "hotornot" value = "not"> <!--a set of radio buttons must all have the same name, the *checked* boolean attribute checks a radio button by default-->

    <input type = "checkbox" name = "spice" value = "Salt"> <!--checkboxes-->
    <input type = "checkbox" name = "spice" value = "Pepper">`


If both checkboxes in the above example are checked, the pair "spice = Salt&Pepper" is sent to the server script.  

* The `<textarea>` element


    <textarea name = "comments" rows = "10" cols = "48">default text in area</textarea> <!--textarea, for multiline text input-->


* The `<select>` element


    <select name = "characters">
        <option value = "Tommy">Perfect Tommy</option>
        <option value = "Penny">Penny Priddy</option>
    </select><!--a menu control-->


* Some HTML 5 input elements


    <input type = "number" min = "0" max = "20"> <!--numbers-->
    <input type = "range" min = "0" max = "20" step = "5"> <!--range, displays a slider-->
    <input type = "color"> <!--color picker-->
    <input type = "date"> <!--date picker-->
    <input type = "email"> <!--email text input (on some mobile devices)-->
    <input type = "tel"> <!--tel text input (on some mobile devices)-->
    <input type = "url"> <!--url input (on some mobile devices-->


The last three input types are all the same on desktop computers, but might display a different keyboard layout on mobile devices.  

Each input control can have (most of the time off course) a name attribute. This is the unique identifier that will be used by the script to access the data send over by the browser after the submit. The data is send over in a dictionary style (name unique identifier : value).  
The name attribute labels the data.

There are two methods the browser uses to get the entered data to the server script: POST and GET.  
With POST, the form data send to the server script is hidden to the user.  
With GET, the form data is added to the URL itself, so the user sees the form data.

Pages that are the result of a POST is not bookmarkable. POST sends a data package apart to the server, and since a bookmark is a URL..... .  
GET is bookmarkable, since GET is a URL with extra data at the end of it.

So think if the user would want to bookmark the page or not to decide if you're going to use a PUT or a GET. E.g., an order should not be bookmarkable (if so, each time you select the bookmark, you would place the order). A search result is often bookmarkable, so the user doesn't need to fill in a form each time to get the results.  
Privacy also plays a role.  
If you use a `<textarea>` you are probably going to send a lot of text. GET would not be easy in that case. Moreover POST has a larger limit of the amount of data that you can send.  

CSS table display layout works well for designing your form's presentation.


    div.tableRow p:first-child {
        text-align: right;
    }


this is a nice CSS trick to align the first column of a table layout to the right, and the second column will be default aligned to the left.  
In a 2 coloumn layout we will get something like


        ............. | ...........
                ..... | .................
                ..... | ..


For accessibility, values of radiobuttons can be labeled, so the visually impaired can hear the choices.


    <input type = "radio" name = "hotornot" value = "hot" id = "hot">
    <label for = "hot">hot</label>


Labels also help strucuture and style the page. To use labels, we first need to add an id attribute to the element to be labelled. The "for" attribute of the label will be set to this id. A label is just like text, only it is labelled. So the above would render


    0 hot


in the browser. id's need to be unique. Labels can come before or after or anywhere in the page in relation to the control it's associated too. As long as the value of the for attribute matches the id, it doesn't matter where the label is.  

Another form element is


    <fieldset>
        <legend>Condiments</legend>
            .....
    </fieldset>


which groups elements in the form together. Within the fieldset we can use `<legend>` to provide a label for the group. The result is a groupbox which has the content of the `<legend>` element as a title.


    <input type = "password" name = "secret">


is the same as a text input, only what you type is masked (by ******). Mind you, the password is sent in clear text to the server script unless you take extra security measures.


    <input type = "file" name = "doc">


sends an entire file to the server script, provided you use the POST method (and the server script knows how to expect a file upload).

    <select name = "characters" multiple>
        <option value = ......>
        .....
    </select>


The *mutltiple* boolean attribute lets us select multiple menu entries.

Most of the `<input>` types in a form can have a placeholder attribute. The placeholder attribute acts as a hint of what is expected in a field, and will be shown in the input as grey fainted text. Once you start typing in the input the hint text disappears.

    <input type = "text" placeholder = "Buckeroo Banzai">

Note that if you do not type anyting in the input, the default placeholder is not submitted with the GET/POST request.

*required* is another boolean attribute that can be used with all of the form controls. It means that a form will not be submitted if there is no content provided for the required input elements.


    <input type = "text" placeholder = "Buckaroo Banzai" required>


## The Top Ten Topics (We Didn't Cover)

Some more CSS selectors:

* Pseudo-elements
* Attribute selectors
* Selecting by siblings
* Combining selectors

There also are vendor-specific CSS properties. They start with a dash followed by the vendor identifier (like moz for mozilla) and another dash.

    -moz-transform

We can do 2D and 3D transformations on elements. We can smooth the transformation with nice animation.  
We can give we pages behaviour, using client side scripting, like JavaScript. Form validation is a usefull application of client side scripting. After all, why sent an invalid form to the server?  
HTML 5 has a set of application programming interfaces (APIs) that are accessible through JavaScript. They open up a whole new universe for webpages, apps, ..... .  
There are services that help you with webfonts (like Google Web Fonts). All modern browsers support the WOFF format.  
There are many tools for creating web pages. They sometimes come up short.  
There also exists a thing called XHTML5. It's complicated, like XML.  
Many web pages are generated by applications running on a server. The pages are generated by server-side scripting or programming. Node.js is a JavaScript server side scripting language with a whole new approach.  
Like `<video>`, there is an element called `<audio>`. Like video, there is no standard for audio. Popular formats are MP3, WAV and Ogg Vorbis. The JavaScript API of the audio element give you lots of control. Thanks to HTML5, you no longer need a plugin (like adobe flash) either.  

## Colophon

This isn't goodbye. Go to wickedlysmart.com .

